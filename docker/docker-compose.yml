version: '3.8'

services:
  # Django Application
  core_django:
    build:
      context: ..
      dockerfile: docker/Dockerfile
    container_name: core_app
    restart: unless-stopped
    env_file:
      - ../src/.env # Loads variables from .env file first
    environment:
      - SERVICE_ROLE=app # This service will run migrations
      # Application specific settings
      - APP_ENV=${APP_ENV:-production} # Default to production if not in .env
      - DEBUG=${DEBUG:-False}

      # Database connection (assembled by app.core.config.settings from these)
      - POSTGRES_SERVER=db
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_DB=${POSTGRES_DB}
      - POSTGRES_PORT=${POSTGRES_PORT:-5432}
      # DATABASE_URL can be explicitly set to override assembly, but usually not needed here

      # Poetry specific settings for running inside the container
      - POETRY_VIRTUALENVS_CREATE=false
      - POETRY_NO_INTERACTION=1
      - PYTHONUNBUFFERED=1 # Good for seeing logs immediately
      - PYTHONDONTWRITEBYTECODE=1

      # For entrypoint.sh to conditionally run migrations
      - RUN_MIGRATIONS=true
    volumes:
      # Mount local code for development (live reload if uvicorn is run with --reload)
      - ../src/core:/app/core
      - ../src/gunicorn_conf.py:/app/gunicorn_conf.py
      - ../src/entrypoint.sh:/app/entrypoint.sh
      - ../src/manage.py:/app/manage.py
    ports:
      - "${APP_PORT:-8000}:8000" # Use APP_PORT from .env or default to 8000
    depends_on:
      db:
        condition: service_healthy
    networks:
      - waplus_network

  # PostgreSQL
  db:
    image: postgres:15-alpine # Using a specific recent version
    container_name: core_db
    restart: unless-stopped
    env_file:
      - ../src/.env # Loads POSTGRES_USER, POSTGRES_PASSWORD, POSTGRES_DB
    # Environment variables are also explicitly listed for clarity and potential overrides
    environment:
      - POSTGRES_HOST_AUTH_METHOD=scram-sha-256 # More secure default
      - PGDATA=/var/lib/postgresql/data/pgdata # Explicitly setting PGDATA
    volumes:
      - postgres_data:/var/lib/postgresql/data/pgdata # Mount for PGDATA
    ports:
      - "${POSTGRES_PORT_HOST:-5432}:5432" # Use POSTGRES_PORT_HOST from .env or default
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB} -q"]
      interval: 10s
      timeout: 5s
      retries: 15 # Increased retries for slower DB init
    networks:
      - waplus_network

  # PGAdmin (optional, for database management)
  pgadmin:
    image: dpage/pgadmin4:latest # Or pin a version like 7.2
    container_name: core_pgadmin
    restart: unless-stopped
    env_file:
      - ../src/.env # Loads PGADMIN_DEFAULT_EMAIL, PGADMIN_DEFAULT_PASSWORD
    environment:
      - PGADMIN_DEFAULT_EMAIL=${PGADMIN_DEFAULT_EMAIL}
      - PGADMIN_DEFAULT_PASSWORD=${PGADMIN_DEFAULT_PASSWORD}
      - PGADMIN_LISTEN_PORT=80 # pgAdmin listens on port 80 inside the container
    volumes:
      - pgadmin_data:/var/lib/pgadmin
      # You might want to mount a servers.json file to preconfigure DB connections
      # - ./pgadmin_servers.json:/pgadmin4/servers.json
    ports:
      - "${PGADMIN_PORT_HOST:-5050}:80" # Host port maps to container's port 80
    depends_on:
      db:
        condition: service_healthy
    networks:
      - waplus_network

#   Traefik for reverse proxy (optional, advanced setup)
  traefik:
     image: traefik:v2.10
     container_name: core_traefik
     command:
       - --api.dashboard=true # Enable dashboard (be careful in prod, secure it)
       # - --api.insecure=true # For local dev dashboard access without auth
       - --log.level=DEBUG
       - --providers.docker=true
       - --providers.docker.exposedbydefault=false
       - --entrypoints.web.address=:80
       # - --entrypoints.websecure.address=:443 # For HTTPS
       # - --certificatesresolvers.myresolver.acme.tlschallenge=true # For Let's Encrypt
       # - --certificatesresolvers.myresolver.acme.email=your-email@example.com
       # - --certificatesresolvers.myresolver.acme.storage=/letsencrypt/acme.json
     ports:
       - "80:80"   # HTTP
       - "443:443" # HTTPS (if configured)
       - "8081:8080" # Traefik dashboard (internal port 8080)
     volumes:
       - /var/run/docker.sock:/var/run/docker.sock:ro # Allow Traefik to listen to Docker events
       # - ./letsencrypt:/letsencrypt # Volume for Let's Encrypt certificates
     networks:
       - waplus_network
     labels: # Labels for Traefik itself if you want to access its dashboard via Traefik
       - "traefik.enable=true"
       - "traefik.http.routers.traefik-dashboard.rule=Host(`traefik.localhost`)" # Example local hostname
       - "traefik.http.routers.traefik-dashboard.service=api@internal"
       - "traefik.http.routers.traefik-dashboard.entrypoints=web"
       # Add middleware for basic auth on dashboard in production
       # - "traefik.http.routers.traefik-dashboard.middlewares=traefik-auth"
       # - "traefik.http.middlewares.traefik-auth.basicauth.users=user:$$apr1$$...$$..."


volumes:
  postgres_data:
    # driver: local # Default driver
  pgadmin_data:

  # letsencrypt: # If using Traefik with Let's Encrypt

networks:
  waplus_network:
    driver: bridge
    # name: waplus_shared_network # If you want to explicitly name it